Проект содержит тесты методом белого ящика
### Спецификация на тесты  
*Поиск точек пересечения двух треугольников*  
```C++
TriangleIntersectionContour(Polygon &PolygonPoints, Triangle Figure1, Triangle Figure2);
```
, где: в PolygonPoints хранятся и записываются точки пересечения, в Figure1 – содержатся вершины треугольника 1, а в Figure2 – вершины треугольника 2.  
В следующей таблице, во входных данных не будет указываться PolygonPoints, т.к. эта переменная хранит полученные точки. А треугольник будет представлен 3 точками Point, т.к. перед вызовом функции **TriangleIntersectionContour**, необходимо записать эти вершины в треугольник Triangle через функцию *SetTriangleVertices(Point Ver1, Point Ver2, Point  Ver3)*. Выходные данные это конечный ожидаемый размер переменной PolygonPoints. 
Имя теста |	Описание сценария | Входные данные | Выходные данные |
:-------- | :---------------- | :------------- | :-------------- |
Triangle2INTriangle1 | Было найдено 3 точки треугольника 2 внутри треугольника 1 → выход | *Треугольник 1:* </br> Point1(110, -170); </br> Point2(60, -30); </br> Point3(170, -30); </br> *Треугольник 2:* </br> Point1(110, -140); </br> Point2(90, -60); </br> Point3(140, -60); | Размер PolygonPoints после вызова = 3 |
PointsInTwoTriangles | В треугольнике 1 были найдены точки → Ищем точки внутри треугольника 2 → Ищем точки пересечения → выход | *Треугольник 1:* </br> Point1(10, -90); </br> Point2(-60, 50); </br> Point3(70, 50); </br> *Треугольник 2:* </br> Point1(50, -90); </br> Point2(0, 30); </br> Point3(100, 100); | Размер PolygonPoints после вызова = 4 |
Triangle1INTriangle2 | В треугольнике 1 не было найдено точек → треугольник 1 в треугольнике 2 → выход | *Треугольник 1:* </br> Point1(110, -140); </br> Point2(90, -60); </br> Point3(140, -60); </br> *Треугольник 2:* </br> Point1(110, -170); </br> Point2(60, -30); </br> Point3(170, -30); | Размер PolygonPoints после вызова = 3 |
NotPointsInTriangle1AndHavePointsInTriangle2 | В треугольнике 1 не было найдено точек → В треугольнике 2 были найдены точки → Ищем точки пересечения → выход | *Треугольник 1:* </br> Point1(110, -170); </br> Point2(60, -30); </br> Point3(170, -30); </br> *Треугольник 2:* </br> Point1(80, -190); </br> Point2(220, -170); </br> Point3(165, 20); | Размер PolygonPoints после вызова = 4 |  
  
*Поиск точек внутри треугольника*  
```C++
SearchPointInTriangle(Polygon& PolygonPoints, vector<LineEquation> LinesFigure1, Triangle Figure2);
```
, где: в PolygonPoints хранятся и записываются точки, найденные внутри треугольника, LinesFigure1 – содержит уравнения прямых сторон одного из треугольников, Figure2 – вершины другого треугольника.  
В следующей таблице, во входных данных не будет указываться PolygonPoints, т.к. эта переменная хранит полученные точки. Уравнения прямых первого треугольника LinesFigure1 будут составляться из 3-х пар точек этого треугольника через функцию *LinesTriangle(vector<LineEquation>& LinesFigure, Triangle Figure)*. Поэтому во входных данных будут указываться 3 точки Point для уравнения прямых первого треугольника и 3 точки для задания вершин второго треугольника через функцию *SetTriangleVertices(Point Ver1, Point Ver2, Point  Ver3)*. Выходные данные это конечный ожидаемый размер переменной PolygonPoints после вызова функции **SearchPointInTriangle**.
Имя теста |	Описание сценария | Входные данные | Выходные данные |
:-------- | :---------------- | :------------- | :-------------- |
PointsInTriangle | Точка внутри треугольника → сохранить точку → выход после того, как проверили все вершины | *Треугольник 1*(точки для прямых): </br> Point1(130, 130); </br> Point2(0, -100); </br> Point3(-70, 100); </br> *Треугольник 2:* </br> Point1(150, 0); </br> Point2(0, 80); </br> Point3(0, 0); | Размер PolygonPoints после вызова = 2 |
NotPointsInTriangle | Точки внутри треугольника нет → выход после того, как проверили все вершины | *Треугольник 1*(точки для прямых): </br> Point1(10, 90); </br> Point2(-60, -50); </br> Point3(70, -50); </br> *Треугольник 2:* </br> Point1(10, -90); </br> Point2(70, 50); </br> Point3(150, -150); | Размер PolygonPoints после вызова = 0 |  
  
*Поиск точки пересечения линий*  
```C++
IntersectionOfLines(Polygon& PolygonPoints, LineEquation Eq1, LineEquation Eq2);
```
, где: в PolygonPoints хранятся и записываются точки пересечения линий, Eq1 – уравнение прямой от первого треугольника, Eq2 – уравнение прямой от второго треугольника.  
В следующей таблице, во входных данных не будет указываться PolygonPoints, т.к. эта переменная хранит полученную точку пересечения. Уравнение прямой будет задаваться через две точки, которые являются отрезком (стороной) треугольника. Выходные данные это конечный ожидаемый размер переменной PolygonPoints после вызова функции **IntersectionOfLines**.  
Имя теста |	Описание сценария | Входные данные | Выходные данные |
:-------- | :---------------- | :------------- | :-------------- |
LinesDontIntersect | Общий определитель равен нулю → выход | *Прямая 1:* </br> Point1(30, 110); </br> Point2(-80, 110); </br> *Прямая 2:* </br> Point1(-50, 110); </br> Point2(60, 110); | Размер PolygonPoints после вызова = 0 |
PointOfIntersectionBehindTheTrianglesRelativeToTheX_axis | Общий определитель не равен нулю → расчет точки пересечения → точка располагается сзади или спереди отрезков по Х линий 1 и 2 → выход | *Прямая 1:* </br> Point1(0, 150); </br> Point2(150, 0); </br> *Прямая 2:* </br> Point1(0, -100); </br> Point2(-70, 100); | Размер PolygonPoints после вызова = 0 |
IntersectionWithVerticalLine1IsOutsideOfTheY_axis | Общий определитель не равен нулю → расчет точки пересечения → точка не располагается сзади или спереди отрезков по Х линий 1 и 2 → точка равна по координате х линии 1 (вертикальная линия) → точка располагается выше или ниже отрезка линии 1 по Y → выход | *Прямая 1:* </br> Point1(0, 150); </br> Point2(0, 0); </br> *Прямая 2:* </br> Point1(0, -100); </br> Point2(-70, 100); | Размер PolygonPoints после вызова = 0 |
IntersectionWithVerticalLine2IsOutsideOfTheY_axis | Общий определитель не равен нулю → расчет точки пересечения → точка не располагается сзади или спереди отрезков по Х линий 1 и 2 → точка не равна по координате х линии 1 (вертикальная линия) → точка равна по координате Х линии 2 (вертикальная линия) точка располагается выше или ниже отрезка линии 2 по Y → выход | *Прямая 1:* </br> Point1(0, -100); </br> Point2(-70, 100); </br> *Прямая 2:* </br> Point1(0, 150); </br> Point2(0, 0); | Размер PolygonPoints после вызова = 0 |
TwoLineSegmentsTouching | Общий определитель не равен нулю → расчет точки пересечения → точка не располагается сзади или спереди отрезков линии 1 и 2 → точка не равна координатам отрезков линии 1 по Х → Точка не равна по координатам отрезков линии 2 по Х. Точка не равна одной из вершин → сохранить точку → выход | *Прямая 1:* </br> Point1(-80, -30); </br> Point2(30, -30); </br> *Прямая 2:* </br> Point1(-30, -30); </br> Point2(-80, 110); | Размер PolygonPoints после вызова = 1 |
SectionsOfTwoLinesHaveACommonStartOrEndPoint | Общий определитель не равен нулю → расчет точки пересечения → точка не располагается сзади или спереди отрезков линии 1 и 2 → точка не равна координатам отрезков линии 1 по Х → Точка не равна по координатам отрезков линии 2 по Х. Точка равна одной из вершин → Точка не была добавлена раньше → сохранить точку → выход | *Прямая 1:* </br> Point1(-80, 110); </br> Point2(30, 110); </br> *Прямая 2:* </br> Point1(30, 110); </br> Point2(-30, 250); | Размер PolygonPoints после вызова = 1 |
SectionsOfTwoLinesHaveACommonStartOrEndPoint_TryingToSaveAgain | Общий определитель не равен нулю → расчет точки пересечения → точка не располагается сзади или спереди отрезков линии 1 и 2 → точка не равна координатам отрезков линии 1 по Х → Точка не равна по координатам отрезков линии 2 по Х. Точка равна одной из вершин → Точка была добавлена раньше → выход | *Прямая 1:* </br> Point1(-80, 110); </br> Point2(30, 110); </br> *Прямая 2:* </br> Point1(30, 110); </br> Point2(-30, 250); </br> (*) Общая точка, которая была добавлена до вызова Point1(30, 110); | Размер PolygonPoints после вызова = 1 |  
  
*Проверка на идентичность двух треугольников*  
```C++
IsIdenticalTriangles(Triangle Figure1, Triangle Figure2);
```
, где: в Figure1 – содержатся вершины треугольника 1, а в Figure2 – вершины треугольника 2. Функция возвращает true/false.  
В следующей таблице, во входных данных треугольник будет представлен 3 точками Point. Выходные данные: значение 1 – треугольники совпадают, 0 – не совпадают.  
Имя теста |	Описание сценария | Входные данные | Выходные данные |
:-------- | :---------------- | :------------- | :-------------- |
IdenticalTriangles | Сверить каждую вершину первого треугольника с вершинами второго треугольника → Если совпадение было найдено. Перейти к следующей вершине первого треугольника → Если вершина не найдена. Вернуть false → После просмотра всех вершин вернуть true | *Треугольник 1:* </br> Point1(110, -170); </br> Point2(60, -30); </br> Point3(170, -30); </br> *Треугольник 2:* </br> Point1(110, -170); </br> Point2(60, -30); </br> Point3(170, -30); | Результат после вызова = 1 |
NotIdenticalTriangles | Сверить каждую вершину первого треугольника с вершинами второго треугольника → Если совпадение было найдено. Перейти к следующей вершине первого треугольника → Если вершина не найдена. Вернуть false → Вершина была не найдена на n-ой итерации. Вернуть false | *Треугольник 1:* </br> Point1(-30, -30); </br> Point2(-80, 110); </br> Point3(30, 110); </br> *Треугольник 2:* </br> Point1(-30, 250); </br> Point2(-80, 110); </br> Point3(30, 110); | Результат после вызова = 0 |


